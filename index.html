<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbrot with Interference Patterns</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            position: absolute;
        }
    </style>
</head>
<body>
    <canvas id="universe"></canvas>

    <script>
        const canvas = document.getElementById('universe');
        const ctx = canvas.getContext('2d');

        const maxIterations = 1000;
        const zoomFactor = 500;
        let offsetX = -canvas.width / 2;
        let offsetY = -canvas.height / 2;

        function mandelbrot(c) {
            let z = c;
            for (let i = 0; i < maxIterations; i++) {
                z = z.mul(z).add(c);
                if (z.abs() > 2) {
                    return i;
                }
            }
            return maxIterations;
        }

        function interferencePattern(c) {
            const pattern1 = Math.sin(c.real) * Math.cos(c.imaginary);
            const pattern2 = Math.cos(c.real) * Math.sin(c.imaginary);
            return pattern1 + pattern2;
        }

        function drawFractal(pattern) {
            for (let x = 0; x < canvas.width; x++) {
                for (let y = 0; y < canvas.height; y++) {
                    const real = (x + offsetX) / zoomFactor;
                    const imaginary = (y + offsetY) / zoomFactor;
                    const c = new Complex(real, imaginary);
                    const value = mandelbrot(c) + interferencePattern(c) * 100;
                    const hue = (value / maxIterations) * 360;
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }

        function zoom(e) {
            const zoomFactorChange = 0.1;
            const x = e.clientX - canvas.getBoundingClientRect().left;
            const y = e.clientY - canvas.getBoundingClientRect().top;

            offsetX -= (x - canvas.width / 2) / zoomFactor;
            offsetY -= (y - canvas.height / 2) / zoomFactor;
            zoomFactor *= e.deltaY > 0 ? (1 + zoomFactorChange) : (1 - zoomFactorChange);

            // Adjust offset to keep the same point under the mouse cursor
            offsetX += (x - canvas.width / 2) / zoomFactor;
            offsetY += (y - canvas.height / 2) / zoomFactor;

            // Clear canvas and redraw
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFractal(interferencePattern);
        }

        canvas.addEventListener('wheel', zoom);

        class Complex {
            constructor(real, imaginary) {
                this.real = real;
                this.imaginary = imaginary;
            }

            add(other) {
                return new Complex(this.real + other.real, this.imaginary + other.imaginary);
            }

            mul(other) {
                return new Complex(
                    this.real * other.real - this.imaginary * other.imaginary,
                    this.real * other.imaginary + this.imaginary * other.real
                );
            }

            abs() {
                return Math.sqrt(this.real * this.real + this.imaginary * this.imaginary);
            }
        }

        // Initial rendering
        drawFractal(interferencePattern);
    </script>
</body>
</html>
